#!/usr/bin/env ruby
# frozen_string_literal: true

Dir.chdir(File.dirname(__dir__))

require('fileutils')
require('json')

if ARGV.size > 0 && ![:major, :minor, :patch].include?(bump = ARGV[0].to_s.strip.to_sym)
  abort('Usage: bin/build [major | minor | patch]')
end

BASE_DIR = Dir.pwd.freeze
RUBY_DIR = File.join(BASE_DIR, 'compilers', 'ruby').freeze
LIB_NAME = File.basename(Dir[File.join(RUBY_DIR, '*.gemspec')].first, '.gemspec').freeze
GEMSPEC_FILES = (Dir[File.join(BASE_DIR, '*.gemspec')] +
  Dir[File.join(BASE_DIR, "#{LIB_NAME}-*", '*.gemspec')]).freeze
VERSION_FILES = Dir[File.join("{#{BASE_DIR},#{RUBY_DIR}}", 'VERSION')].freeze
VERSION_FILE_RUBY = File.join(RUBY_DIR, 'lib', LIB_NAME, 'version.rb').freeze
TEST_COMMAND = File.join(RUBY_DIR, 'bin', 'test').freeze

SRC_DIR = File.join(BASE_DIR, 'src').freeze
DIST_DIR = File.join(BASE_DIR, 'dist').freeze
ALL_FILE = File.join(DIST_DIR, "#{LIB_NAME}-all.js").freeze
SIZES_FILE = File.join(BASE_DIR, 'sizes.json').freeze

COPYRIGHT = File.readlines(File.join(BASE_DIR, 'LICENSE')).first.strip
OLD_VERSION = File.read(VERSION_FILES.first).strip.freeze
major, minor, patch = OLD_VERSION.split('.').map(&:to_i)
NEW_VERSION =
  case bump || :patch
  when :major then "#{major + 1}.0.0"
  when :minor then "#{major}.#{minor + 1}.0"
  when :patch then "#{major}.#{minor}.#{patch + 1}"
  end

DEPENDENCIES = [
  {name: 'Terser', cmd_check: 'which terser', cmd_install: 'npm install -g terser'}.freeze,
  {name: 'NPM', cmd_check: 'which npm', cmd_install: 'brew install npm'}.freeze,
  {name: 'Homebrew', cmd_check: 'which brew', cmd_install: '/bin/bash -c "$(curl -fsSL '\
    'https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"'}.freeze,
  {name: 'Ruby gems', cmd_check: "cd #{RUBY_DIR} && bundle check", cmd_install: "cd #{RUBY_DIR} && " +
    'bundle install'},
].freeze

############################################################################################################
## Tasks                                                                                                  ##
############################################################################################################

def install_dependencies
  missing = DEPENDENCIES.each_with_object([]) do |info, missing|
    `#{info[:cmd_check]} 2>&1`
    $?.exitstatus == 0 ? next : missing.unshift(info)
  end

  if missing.empty?
    finish_task('Dependencies are installed')
    return
  end

  begin_task('Some dependencies need to be installed')

  print("Install #{missing.map { |l| l[:name] }.join(', ')}? (y/n) ")
  finish_task(1) if gets.strip.downcase != 'y'

  missing.each do |info|
    task(
      preamble: "Installing #{info[:name]}...",
      command: info[:cmd_install],
      success: "#{info[:name]} installed successfully",
      failure: "#{info[:name]} installation failed",
    )
  end
end

def test
  task(
    preamble: 'Running tests...',
    command: TEST_COMMAND,
    success: 'Tests passed',
  )
end

def update_version(version = NEW_VERSION, quiet = false)
  begin_task('Updating version number...') unless quiet

  VERSION_FILES.each do |version_file|
    File.write(version_file, "#{version}\n")
  end

  ruby = File.read(VERSION_FILE_RUBY)
  ruby.sub!(/(?<=VERSION = (['"]))(\d+\.\d+\.\d+)(?=\1)/, version)
  File.write(VERSION_FILE_RUBY, ruby)

  finish_task('Version number updated') unless quiet
end

def build_ruby
  multiple = GEMSPEC_FILES.size > 1

  GEMSPEC_FILES.each do |gemspec_file|
    lib_name = File.basename(gemspec_file, '.gemspec')

    task(
      preamble: "Building Ruby gem#{" (#{lib_name})" if multiple}...",
      command: ["cd #{File.dirname(gemspec_file)}", "gem build #{File.basename(gemspec_file)}"],
      success: "Ruby gem built (#{lib_name}-#{NEW_VERSION}.gem)",
    )
  end
end

def build_javascript
  begin_task('Building JavaScript files...')

  FileUtils.mkdir_p(DIST_DIR)

  src_files = Dir.glob(File.join(SRC_DIR, '*.js')).sort_by(&:size)
  src_files.each { |src_file| build_javascript_file(src_file) }
  build_javascript_file(*src_files)

  finish_task('JavaScript files built')
end

def build_javascript_file(*src_files)
  all = src_files.size > 1
  dist_file = all ? ALL_FILE : src_files.first.sub(SRC_DIR, DIST_DIR)
  dist_file_min = dist_file.sub(/\.js$/, '.min.js')

  lib_names = []
  unminified = []

  src_files.each do |src_file|
    content = File.read(src_file)
    lib_name = content[/^(let|class) (\w+)/, 2]

    content.gsub!(/^ *\/\*(.*?)\*\/\n/m, '')
    content.gsub!(/^ *\/\/.*\n/, '')
    content.prepend(javascript_comment(lib_name))

    lib_names << lib_name
    unminified << content
  end

  lib_names = lib_names.join(', ')
  unminified = unminified.join("\n")

  File.write(dist_file, unminified)

  task(command: "terser #{src_files.join(' ')} -c --comments /^$/ --mangle-props regex=/^_.*/ --format "\
    "\"preamble='#{javascript_comment(lib_names, :minified)}'\" --output #{dist_file_min}")
end

def javascript_comment(lib_name, minified = false)
  if minified
    "/* #{lib_name} v#{NEW_VERSION} :: #{COPYRIGHT} :: MIT License */"
  else
    <<~EOS
      /**
       * #{lib_name}
       * #{COPYRIGHT}
       *
       * @license MIT
       * @version #{NEW_VERSION}
       */
    EOS
  end
end

def write_sizes
  data = File.exists?(SIZES_FILE) ? JSON.parse(File.read(SIZES_FILE)) : {}

  Dir[File.join(DIST_DIR, '*.js')].sort.each do |path|
    (data[File.basename(path)] ||= {})[NEW_VERSION] = [
      `wc -c #{path}`.strip.to_i,
      `gzip -c #{path} | wc -c`.strip.to_i,
    ]
  end

  File.write(SIZES_FILE, "#{JSON.pretty_generate(data).gsub(/\[\s*(\d+),\s*(\d+)\s*\]/, '[\\1, \\2]')}\n")
end

############################################################################################################
## Utils                                                                                                  ##
############################################################################################################

def task(preamble: nil, command:, success: nil, failure: nil)
  begin_task(preamble) if preamble
  system(Array(command).join(' && '))

  if $?.exitstatus != 0
    finish_task($?.exitstatus, failure)
  elsif success
    finish_task(success)
  end
end

def begin_task(str)
  puts("\e[33m\u270e #{str}\e[39m")
end

def finish_task(*args)
  status = args.first.kind_of?(Integer) ? args.shift : 0
  message = args.shift

  if status == 0
    puts("\e[32m\u2714 #{message}\e[39m")
  else
    puts("\e[31m\u2718 #{message || 'Build aborted'}\e[39m")
    exit(status)
  end
end

############################################################################################################

install_dependencies
test
update_version

begin
  build_ruby
  build_javascript
  write_sizes
ensure
  (update_version(OLD_VERSION, :quiet) rescue nil) if $!
end

finish_task("Version #{NEW_VERSION} built successfully!")
